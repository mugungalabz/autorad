1) Hardcoded numbers get sent through a scale function, 
which normalizes them to the default value. s(n) is "s" for "scale"

1024 - 456
    ---becomes---
s(1024 - 456) 

2) xxs(n) is the scaled version of xx(n). 
    # When comparing to a 0-255 value for modes, it remains xx(n)
    # When creating an offset or renderable value, change to xxs(n)

let randomOffset2 = xx(26) < 165 ? 0 - xxs(26) : xxs(26);
    ---becomes---
let randomOffset2 = xx(26) < 165 ? 0 - xxs(26) : xxs(26);

3) Since we scale the frameOffset at the beginning, combinations of hardcode numbers
and frame offset variables only call the scale function on the hardcoded numbers:

ellipse(512 + frameOffset, 512 + frameOffset2,1024 - 456 - frameOffset, 1024 - 456 - frameOffset);
    ---becomes---
ellipse(s(512) + frameOffset, s(512) + frameOffset2, s(1024 - 456) - frameOffset, s(1024 - 456) - frameOffset);

4) value for xBetween need to be Scaled. This will be done within the function itself.

xBetween(x(3), -100, 100)
    ----becomes------
xsBetween(x(3), -100, 100)

5) DIM is the scaled Dimension, replacing 1024

let w_lerp = 1024; let h_lerp = 1024;
    ----becomes----
let w_lerp = DIM; let h_lerp = DIM;

------------NEW SCALING FUNCTIONS----------
function xsBetween(x, a, b) {
  a = s(a); b = s(b);
  return (int)(a + (xx(x) / 255.0 * (b - a)));
}
function xxs(a) { return (unhex(hash.substring(a, a + 2) / DEFAULT_SIZE) * DIM); }
function s(a) { return (a / DEFAULT_SIZE) * DIM }